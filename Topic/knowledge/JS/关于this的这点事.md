```js
关于this的理解：https://juejin.im/post/5e6358256fb9a07cd80f2e70
```

### 1.默认绑定

1.全局环境中，this默认绑定到window

2.函数独立调用时，this默认绑定到window

3.被嵌套的函数独立调用时，this默认绑定到window

4.IIFE立即执行函数实际上是函数声明后直接调用执行

5.闭包的this默认绑定到window对象，但又常常需要访问嵌套函数的this，所以常常在嵌套函数中使用var that = this,然后在闭包中使用that替代this,使用作用域查找的方法来找到嵌套函数的this值。

### 2.隐式绑定

```
被直接对象所包含的函数调用时，也称为方法调用，this隐式绑定到该直接对象。
```

**this 永远指向最后调用它的那个对象**（不考虑箭头函数）

### 3.隐式丢失

```
指隐式绑定的函数丢失绑定对象，从而默认绑定到window.
```

两种容易发生隐式丢失问题：

1. 使用另一个变量来给函数取别名；
2. 将函数作为参数传递时会被隐式赋值，回调函数丢失this绑定；

### 4.显示绑定

1.通过call()、apply()、bind()方法将对象绑定到this上。对于被调用的函数来说，叫做间接调用。

2.普通的显示绑定无法解决隐式丢失问题

3.硬绑定：是显示绑定的一个变种，使this不能再被修改。

**API：javascript中新增了许多内置函数，具有显式绑定的功能，如数组的5个迭代方法：map()、forEach()、filter()、some()、every()**

**总结：**

- `this` 永远指向最后调用它的那个对象
- 匿名函数的`this`永远指向`window`
- 使用`.call()`或者`.apply()`的函数是会直接执行的
- bind()`是创建一个新的函数，需要手动调用才会执行
- 如果`call、apply、bind`接收到的第一个参数是空或者`null、undefined`的话，则会忽略这个参数`forEach、map、filter`函数的第二个参数也是能显式绑定`this`的

### 5.new 绑定

如果函数或者方法调用之前带有关键字new,它就构成构造函数调用。对于this绑定来说，称为New绑定。

1. 构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值
2. 如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果
3. 如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象

### 6.严格模式

1. 严格模式下，独立调用的函数的this指向undefined
2. 在非严格模式下，使用函数的call()或apply()方法时，null或undefined值会被转换为全局对象。而在严格模式下，函数的this值始终是指定的值

　this的四种绑定规则：默认绑定、隐式绑定、显式绑定和new绑定，分别对应函数的四种[调用方式](http://www.cnblogs.com/xiaohuochai/p/5702813.html#anchor3)：独立调用、方法调用、间接调用和构造函数调用。

***以上来自***：https://www.cnblogs.com/xiaohuochai/p/5735901.html

### 7.箭头函数绑定

箭头函数里面的this是由外层作用域来决定的，**且指向函数定义时的this而非执行时。**

```
箭头函数中没有this绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this,否则，this为undefined
```

**总结：**

1. 它里面的`this`是由外层作用域来决定的，且指向函数定义时的`this`而非执行时
2. 字面量创建的对象，作用域是`window`，如果里面有箭头函数属性的话，`this`指向的是`window`
3. 构造函数创建的对象，作用域是可以理解为是这个构造函数，且这个构造函数的`this`是指向新建的对象的，因此`this`指向这个对象。
4. 箭头函数的`this`是无法通过`bind、call、apply`来**直接**修改，但是可以通过改变作用域中`this`的指向来间接修改。

