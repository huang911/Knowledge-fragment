**Set:** 

1.类似于数组，成员的值都是唯一的，没有重复的值。set本身是一个构造函数，用来生成Set数据结构。

2.Set函数可以接受一个数组（或者具有iterable接口的其他数据结构）作为参数，用来初始化。

3.Set可以用于去重，采用的是精确相等运算符“===”，主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。但两个对象总是不相等的，指向的地址不同。（Array.from可以将Set结构转换为数组）

4.Set的属性：Set.prototype.constructor,Set.prototype.size;

 Set的方法：

 add(value): 添加某个值，返回Set结构本身；

 delete(value): 删除某个值，返回布尔值，表示删除是否成功。

 has(value): 返回一个布尔值，表示该值是否为Set的成员。

 clear(): 清除所有成员，没有返回值。

5.遍历操作

(1).keys()返回键名的遍历器；（2）values():返回键值的遍历器。（3）entries(): 返回键值对的遍历器；（4）.forEach(): 使用回调函数遍历每个成员。



**WeakSet：**

WeakSet的成员只能是对象，而不能是其他类型的值。WeakSet 不可遍历。

这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为`0`，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，**WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。**

由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。

其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

运用：

WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

**Map**

不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作`Map`构造函数的参数,Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应.

1.属性及操作方法：

size属性返回Map结构的成员总数。

（1）.set（key, value)返回当前的Map对象，可以采用链式写法；

（2）get(key),找不到key，则返回undefined;

（3）has(key),返回一个布尔值；

（4）delete(key),返回一个布尔值；

（5）clear()清除所有成员，没有返回值。

2.遍历方法：

- `keys()`：返回键名的遍历器。
- `values()`：返回键值的遍历器。
- `entries()`：返回所有成员的遍历器。
- `forEach()`：遍历 Map 的所有成员。

**WeakMap**

`WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。

总之，`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏。

注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。

1.WeakMap和Map的区别：

一是没有遍历操作（即没有`keys()`、`values()`和`entries()`方法），也没有`size`属性。

二是无法清空，即不支持`clear`方法。因此，`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`。

