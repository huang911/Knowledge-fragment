**1.扁平化处理**

```js
 var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
	let a = [];
	function fn(arr) {
		arr.forEach(item => {
			if (Array.isArray(item)) {
				fn(item);
			} else {
				a.push(item);
			}
		});
		return Array.from(new Set(a)).sort((a,b)=> a-b);
	}

	console.log(fn(arr));
```

**2.对象转换成对应数组**

```js
/*
   Object = {1:222, 2:456, 5:777}
   转换为： 对应年月的收益 [222, 456, null, null, 777, null, null, null, null, null, null, null, null]
 */
// 最原始的for循环
function objectTransfrom(object) {
    let arr = new Array(13).fill(null);
    for (let key in object) {
        for (let i = 0; i < arr.length; i++) {
            if (+key === i) {
                arr[i] = object[key];
            }
        }
    }
    return arr.slice(1);
}
let a = objectTransfrom({1:222, 2:456, 5:777});
console.log(a);

//forEach(会遍历数组, 循环体内没有返回值,forEach()循环可以改变原来数组的内容, forEach()有三个参数, 第一个参数是当前元素, 第二个参数是当前元素的索引, 第三个参数是当前元素所属的数组.)

//map(map()的主要作用, 其实是创建一个新的数组, map()的参数和forEach()是一样的)
//什么都没有的数组元素叫做槽(slot)稀疏数组，一般方法都会忽略，可以用 Array.prototype.fill、Array.from 或者 [...arr] 的方式转换。
function objectTransfrom2(object) {
    let arr = new Array(13).fill(null)
    let temp = arr.map((item, index) => object[index] ? object[index] :  null).slice(1);
        return temp;
    }
let a2 = objectTransfrom2({1:222, 2:456, 5:777});
console.log(a2);

//filter()参数和forEach()也是一样的, filter()主要是过滤的, 用来过滤数组中不满足条件的元素, 把满足条件的元素放到新的数组里, 并且不会改变原数组.

//它会遍历数组, 在循环体内写条件, 如果每一项都是true, 就会返回true, 只要有一个是false, 就会返回false, 

//历数组的每一项, 然后根据循环体内的条件去判断, 只要有一个是true, 就会停止循环.
```

**3.遍历输出index**

```js
 <!-- 使下面这个函数输出0-9 -->
   /*function test() {
		for (var i = 0; i< 10; i++){
			setTimeout(() => {
				console.log(i);
		    }, 1000)
		}
	}
	test();*/
	
  // 利用 let 变量的特性 — 在每一次 for 循环的过程中，let 声明的变量会在当前的块级作用域里面（for 循环的 body 体，也即两个花括号之间的内容区域）创建一个文法环境（LexicalEnvironment），该环境里面包括了当前 for 循环过程中的 i
	/*function test1() {
		for (let i = 0; i< 10; i++){
			setTimeout(() => {
				console.log(i);
		    }, 1000)
		}
	}
	test1();*/

/*
	function test2() {
		setTimeout(() => {
			for (var i = 0; i< 10; i++){
				console.log(i);
			}
	    }, 1000)
	}
	test2();
*/
	// setTimeout(function[,delay, param1, param2]),delay: 可选，param:可选
/*	function test3() {
		for (var i = 0; i< 10; i++){
			setTimeout((i) => {
				console.log(i);
		    }, 1000, i)
		}
	}
	test3();
*/
	// 闭包
	function test4() {
		for (var i = 0; i< 10; i++){
			((i) => {
				setTimeout(() => {
				console.log(i);
		    }, 1000)
			})(i);	
		}
	}
	test4();

```

**4.使用迭代的方式实现flattern函数。**

```
const flattern = function(arr) {
	while(arr.some(item => Array.isArray(item))){
		arr = [].concat(...arr);
	}
	return arr;
}
```

递归实现:

```
const flattern = array =>  array.reduce((acc, cur) => (Array.isArray(cur)? [...acc, ...flttern(cur)]))
```

字符串转换：

```
const flattern = function(arr) {
	return arr.toString().split(',').map(item => item = parseInt(item))
}
```

