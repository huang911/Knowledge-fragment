**1.扁平化处理**

```js
 var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
	let a = [];
	function fn(arr) {
		arr.forEach(item => {
			if (Array.isArray(item)) {
				fn(item);
			} else {
				a.push(item);
			}
		});
		return Array.from(new Set(a)).sort((a,b)=> a-b);
	}

	console.log(fn(arr));
```

**2.对象转换成对应数组**

```js
/*
   Object = {1:222, 2:456, 5:777}
   转换为： 对应年月的收益 [222, 456, null, null, 777, null, null, null, null, null, null, null, null]
 */
// 最原始的for循环
function objectTransfrom(object) {
    let arr = new Array(13).fill(null);
    for (let key in object) {
        for (let i = 0; i < arr.length; i++) {
            if (+key === i) {
                arr[i] = object[key];
            }
        }
    }
    return arr.slice(1);
}
let a = objectTransfrom({1:222, 2:456, 5:777});
console.log(a);

//forEach(会遍历数组, 循环体内没有返回值,forEach()循环可以改变原来数组的内容, forEach()有三个参数, 第一个参数是当前元素, 第二个参数是当前元素的索引, 第三个参数是当前元素所属的数组.)

//map(map()的主要作用, 其实是创建一个新的数组, map()的参数和forEach()是一样的)
//什么都没有的数组元素叫做槽(slot)稀疏数组，一般方法都会忽略，可以用 Array.prototype.fill、Array.from 或者 [...arr] 的方式转换。
function objectTransfrom2(object) {
    let arr = new Array(13).fill(null)
    let temp = arr.map((item, index) => object[index] ? object[index] :  null).slice(1);
        return temp;
    }
let a2 = objectTransfrom2({1:222, 2:456, 5:777});
console.log(a2);

//filter()参数和forEach()也是一样的, filter()主要是过滤的, 用来过滤数组中不满足条件的元素, 把满足条件的元素放到新的数组里, 并且不会改变原数组.

//它会遍历数组, 在循环体内写条件, 如果每一项都是true, 就会返回true, 只要有一个是false, 就会返回false, 

//历数组的每一项, 然后根据循环体内的条件去判断, 只要有一个是true, 就会停止循环.
```

**2.实现一个sleep函数**

```js
// Promise
const sleep = time => {
	return new Promise(reslove => setTimeout(reslove, time))
}
sleep(1000).the(() => {
	console.log(1);
})
// Generator
function* sleepGenator(time) {
	yield new Promise(function(reslove, reject) {
		setTimeout(reslove, time);
	})
}
sleepGenator(1000).next().vlaue.then(() => {console.log(1)})
// async
function sleep(time) {
    return new Promise(reslove => setTimeout(reslove, time))
}
async function output() {
    let out = await sleep(1000);
    console.log(1);
    return out;
}
output();
// ES5
function sleep(callback, time) {
    if(typeof callback === 'function') {
		setTimeout(callback, time)
    }
}
function output() {
    console.log(1);
}
sleep(output, 1000);
```

